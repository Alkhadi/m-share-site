#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import url from 'url';

// ---------- Config sourced from env (provider + credentials) ----------
const PROVIDER = (process.env.VOICECOACH_PROVIDER || 'webspeech').toLowerCase(); // 'azure' | 'elevenlabs' | 'webspeech'
const AZURE_KEY = process.env.VOICECOACH_AZURE_KEY || '';
const AZURE_REGION = process.env.VOICECOACH_AZURE_REGION || '';
const AZURE_VOICE = process.env.VOICECOACH_AZURE_VOICE || 'en-GB-LibbyNeural';
const EL_KEY = process.env.ELEVENLABS_API_KEY || '';
const EL_VOICE_ID = process.env.ELEVENLABS_VOICE_ID || '21m00Tcm4TlvDq8ikWAM'; // Rachel default

// ---------- Paths ----------
const ROOT = process.cwd();
const ASSET_DIR = path.join(ROOT, 'assets', 'js');
const OUT_FILE = path.join(ASSET_DIR, 'voice-coach-pro.js');

// ---------- Utility ----------
function walk(dir, acc = []) {
  const list = fs.readdirSync(dir, { withFileTypes: true });
  for (const d of list) {
    const p = path.join(dir, d.name);
    if (d.isDirectory()) walk(p, acc);
    else acc.push(p);
  }
  return acc;
}
function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}
function containsOnce(hay, needle) {
  const rx = new RegExp(needle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
  return rx.test(hay);
}

// ---------- Writer ----------
function writeVoiceCoachFile() {
  ensureDir(ASSET_DIR);

  // Base runtime (unchanged features)
  const jsCore = `/* ==========================================================================
   Voice Coach Pro (site-wide) — generated by fix-voice-coach.mjs
   Provider: ${PROVIDER.toUpperCase()}
   If a cloud provider is not configured, falls back to Web Speech.
   ========================================================================== */
(()=>{ 'use strict';
  const VC_CFG = {
    provider: ${JSON.stringify(PROVIDER)},
    azure: { key: ${JSON.stringify(AZURE_KEY)}, region: ${JSON.stringify(AZURE_REGION)}, voice: ${JSON.stringify(AZURE_VOICE)} },
    elevenlabs: { key: ${JSON.stringify(EL_KEY)}, voiceId: ${JSON.stringify(EL_VOICE_ID)} },
    defaults: { rate: 1.0, pitch: 1.0, locale: 'en-GB', preferredGender: 'female' }
  };

  // ---------- Small helpers ----------
  const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
  function clamp(n,a,b){ n=Number(n); if(isNaN(n)) n=a; return Math.min(b,Math.max(a,n)); }
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }
  function on(el, evt, fn, opts){ if(el) el.addEventListener(evt, fn, opts); }
  function esc(s){ return String(s||'').replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[m])); }

  // ---------- Audio/TTS engines ----------
  class VoiceQueue {
    constructor(){
      this._queue = [];
      this._playing = false;
      this._cancelled = false;
      this._audioCtx = null;
      this._current = null;
    }
    get speaking(){ return this._playing; }
    cancel(){ this._cancelled = true; try{ window.speechSynthesis && speechSynthesis.cancel(); }catch{}; if(this._current && this._current.srcObject){ try{ this._current.pause(); this._current.src=''; }catch{} } this._queue.length = 0; this._playing = false; }
    async _ensureCtx(){ try{ this._audioCtx = this._audioCtx || new (window.AudioContext||window.webkitAudioContext)(); if (this._audioCtx.state === 'suspended') await this._audioCtx.resume(); }catch{} }
    async speak(items, opts={}){
      const list = Array.isArray(items) ? items : [{ text: String(items) }];
      list.forEach(i => this._queue.push(Object.assign({ pauseMs: 0 }, i)));
      if (this._playing) return;
      this._playing = true; this._cancelled = false;
      await this._ensureCtx();
      while(this._queue.length && !this._cancelled){
        const it = this._queue.shift();
        if(!it || !it.text){ if(it && it.pauseMs) await sleep(it.pauseMs); continue; }
        try {
          if (VC_CFG.provider === 'azure' && VC_CFG.azure.key && VC_CFG.azure.region) {
            await this._playAzure(it.text, opts);
          } else if (VC_CFG.provider === 'elevenlabs' && VC_CFG.elevenlabs.key) {
            await this._playElevenLabs(it.text, opts);
          } else {
            await this._playWebSpeech(it.text, opts);
          }
        } catch(e){ console.warn('[VoiceCoach] speak error:', e); }
        if (it.pauseMs && !this._cancelled) await sleep(it.pauseMs);
      }
      this._playing = false;
    }
    async _playWebSpeech(text, opts={}){
      if (!('speechSynthesis' in window)) throw new Error('Web Speech not supported');
      const u = new SpeechSynthesisUtterance(text);
      try {
        const voices = speechSynthesis.getVoices() || [];
        const wantGB = (v)=> (v.lang || '').toLowerCase().startsWith('en-gb');
        const wantGender = VC_CFG.defaults.preferredGender;
        let best = null, score = -1;
        for (const v of voices){
          let s = 0;
          if (wantGB(v)) s+=100;
          const name = (v.name||'').toLowerCase();
          if (name.includes('female')) s+= (wantGender==='female'? 8:0);
          if (name.includes('google uk english')) s+=60;
          if (name.includes('microsoft')) s+=8;
          if (s>score){ best=v; score=s; }
        }
        if (best) u.voice = best;
      } catch {}
      u.rate = clamp(opts.rate ?? VC_CFG.defaults.rate, 0.5, 1.4);
      u.pitch = clamp(opts.pitch ?? VC_CFG.defaults.pitch, 0.5, 1.6);
      u.onend = ()=>{};
      return new Promise((res)=>{
        try { speechSynthesis.cancel(); } catch {}
        const done = ()=>{ u.onend=null; u.onerror=null; res(); };
        u.onerror = ()=>{ done(); };
        u.onend = ()=>{ done(); };
        speechSynthesis.speak(u);
      });
    }
    async _playAzure(text){
      const key = VC_CFG.azure.key, region = VC_CFG.azure.region, voice = VC_CFG.azure.voice || 'en-GB-LibbyNeural';
      const url = \`https://\${region}.tts.speech.microsoft.com/cognitiveservices/v1\`;
      const ssml = \`<speak version="1.0" xml:lang="en-GB"><voice xml:lang="en-GB" name="\${voice}">\${text.replace(/&/g,'&amp;').replace(/</g,'&lt;')}</voice></speak>\`;
      const r = await fetch(url, {
        method: 'POST',
        headers: {
          'Ocp-Apim-Subscription-Key': key,
          'Content-Type': 'application/ssml+xml',
          'X-Microsoft-OutputFormat': 'audio-24khz-48kbitrate-mono-mp3'
        },
        body: ssml
      });
      if (!r.ok) throw new Error('Azure TTS failed: ' + r.status);
      const blob = await r.blob();
      await this._playBlob(blob);
    }
    async _playElevenLabs(text){
      const key = VC_CFG.elevenlabs.key, voiceId = VC_CFG.elevenlabs.voiceId;
      const url = \`https://api.elevenlabs.io/v1/text-to-speech/\${voiceId}/stream\`;
      const r = await fetch(url, {
        method: 'POST',
        headers: {
          'xi-api-key': key,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          text, model_id: 'eleven_monolingual_v1',
          voice_settings: { stability: 0.4, similarity_boost: 0.7 }
        })
      });
      if (!r.ok) throw new Error('ElevenLabs TTS failed: ' + r.status);
      const blob = await r.blob();
      await this._playBlob(blob);
    }
    async _playBlob(blob){
      return new Promise((res)=>{
        try{
          const a = new Audio();
          a.preload='auto';
          a.src = URL.createObjectURL(blob);
          a.onended = ()=>{ URL.revokeObjectURL(a.src); res(); };
          a.onerror = ()=>{ URL.revokeObjectURL(a.src); res(); };
          this._current = a;
          a.play().catch(()=>res());
        }catch{ res(); }
      });
    }
  }

  const Queue = new VoiceQueue();

  // ---------- Section logic (summarised; unchanged from your last version) ----------
  function graphemeSplit(word){
    const W = (word||'').toLowerCase().replace(/[^a-z]/g,'');
    if (!W) return [];
    const G = ['tch','dge','igh','tion','sion','ture','eigh','ck','sh','ch','th','ph','wh','ng','nk','qu','ai','ay','ee','ea','oa','ow','oi','oy','ou','ow','aw','au','ar','er','ir','or','ur'];
    const out = []; let i = 0;
    while (i < W.length){
      let take = 1, best = W[i];
      for (const g of G){ if (W.startsWith(g,i) && g.length>take){ take=g.length; best=g; } }
      out.push(best); i += take;
    }
    return out;
  }

  function segmentBlendUI(){
    const root = qs('#vcPhon'); if (!root) return;
    const wordInp = qs('#vcWord'), paceSel = qs('#vcPace'), playBtn = qs('#vcPlay'), stopBtn = qs('#vcStop');
    if (!qs('#vcStart', root)){
      const startBtn = document.createElement('button');
      startBtn.id = 'vcStart'; startBtn.type='button'; startBtn.className='btn btn-success';
      startBtn.textContent = 'Start';
      const actions = playBtn?.parentElement;
      if (actions) actions.insertBefore(startBtn, playBtn);
      on(startBtn, 'click', ()=>{ try{ root.scrollIntoView({behavior:'smooth',block:'center'});}catch{} });
    }
    const out = qs('#vcOut');
    let running = false;
    on(playBtn,'click', async ()=>{
      if (running) return;
      running = true; stopBtn.disabled = false; playBtn.disabled = true;
      const w = (wordInp?.value||'').trim();
      const parts = graphemeSplit(w);
      const pace = (paceSel?.value || 'med');
      const gap = (pace==='slow')? 700 : (pace==='fast'? 250 : 450);
      out.innerHTML = parts.length ? \`<span class="muted">/ \${esc(parts.join(' / '))} / → <b>\${esc(w)}</b></span>\` : '';
      const items = [];
      parts.forEach((p,i)=>{ items.push({ text: p }); if (i<parts.length-1) items.push({ text: '—', pauseMs: 80 }); items.push({ pauseMs: gap }); });
      items.push({ pauseMs: 300 });
      if (parts.length>=2){ items.push({ text: parts.slice(0,2).join('') , pauseMs: gap }); }
      items.push({ text: w, pauseMs: 0 });
      try{ await Queue.speak(items, { rate: 0.95 }); } finally {
        running=false; playBtn.disabled=false; stopBtn.disabled = true;
      }
    });
    on(stopBtn,'click', ()=>{ Queue.cancel(); stopBtn.disabled=true; const b = qs('#vcPlay'); if (b) b.disabled=false; });
  }

  function soundStudio(){
    const root = qs('#svStudio'); if (!root) return;
    const sel = qs('#svSelect'), tiles = qs('#svTiles'), out = qs('#svOut');
    const btnAll = qs('#svPractice'), btnStop = qs('#svStop');
    const btnCam = qs('#svCam'), btnCamOff = qs('#svCamOff'), mirrorWrap = qs('#svMirrorWrap'), mirror = qs('#svMirror');
    const SETS = {
      short:[{g:'a',ex:['cat','map']},{g:'e',ex:['bed','hem']},{g:'i',ex:['sit','milk']},{g:'o',ex:['hot','pond']},{g:'u',ex:['sun','drum']}],
      long:[{g:'a',ex:['late','paper']},{g:'e',ex:['tree','even']},{g:'i',ex:['time','pilot']},{g:'o',ex:['home','open']},{g:'u',ex:['unit','music']}],
      digraphs:[{g:'sh',ex:['ship','brush']},{g:'ch',ex:['chat','teacher']},{g:'th',ex:['thin','this']},{g:'ph',ex:['phone','graph']},{g:'wh',ex:['when','whale']},{g:'ck',ex:['back','packet']},{g:'ng',ex:['sing','ring']},{g:'nk',ex:['bank','thank']},{g:'qu',ex:['quick','quiet']},{g:'tch',ex:['catch','match']},{g:'dge',ex:['bridge','edge']},{g:'igh',ex:['high','night']},{g:'tion',ex:['nation','action']},{g:'sion',ex:['vision','decision']},{g:'ture',ex:['picture','nature']}],
      teams:[{g:'ai/ay',ex:['rain','day']},{g:'ee/ea',ex:['see','team']},{g:'ea (head)',ex:['head','bread']},{g:'oa/ow',ex:['boat','snow']},{g:'oi/oy',ex:['coin','boy']},{g:'ou/ow',ex:['sound','cloud']},{g:'au/aw',ex:['cause','saw']},{g:'oo (long)',ex:['moon','food']},{g:'oo (short)',ex:['book','good']},{g:'ue/ui/ew',ex:['blue','suit']},{g:'ie/y (ī)',ex:['pie','try']},{g:'eigh/ei/ey (ā)',ex:['eight','they']}],
      r:[{g:'ar',ex:['car','start']},{g:'er/ir/ur',ex:['her','bird']},{g:'or',ex:['fork','north']},{g:'air',ex:['chair','hair']},{g:'ear (er)',ex:['learn','earth']},{g:'ore',ex:['more','shore']}],
      silent:[{g:'kn/gn',ex:['knee','gnome']},{g:'wr',ex:['write','wrist']},{g:'mb',ex:['thumb','comb']},{g:'igh',ex:['light']},{g:'ps-',ex:['psychology','pseudonym']},{g:'mn-',ex:['mnemonic']},{g:'bt',ex:['debt','doubt']},{g:'sc (sce/sci)',ex:['scene','science']}]
    };
    let cur = [];
    function paint(topic){
      tiles.innerHTML = '';
      cur = SETS[topic] || [];
      cur.forEach(s=>{
        const b = document.createElement('button');
        b.type='button'; b.className='btn'; b.style.minWidth='84px'; b.textContent=s.g;
        on(b, 'click', async ()=>{
          try{ root.scrollIntoView({behavior:'smooth',block:'center'});}catch{}
          out.innerHTML = '<strong>'+esc(s.g)+'</strong>: '+esc(s.ex.join(', '));
          await Queue.speak([{ text: s.g, pauseMs: 350 }, ...s.ex.map(w=>({ text:w, pauseMs: 300 }))], { rate: 0.95 });
          btnAll.disabled = false; btnStop.disabled = false;
        });
        tiles.appendChild(b);
      });
      out.textContent = 'Tap a tile to hear the sound and examples.';
      btnAll.disabled = cur.length===0; btnStop.disabled = true;
    }
    paint(sel?.value || 'short');
    on(sel,'change',()=>paint(sel.value));
    let loop=false, stopLoop=()=>{ loop=false; btnStop.disabled=true; };
    on(btnAll, 'click', async ()=>{
      if (!cur.length) return;
      loop = true; btnStop.disabled=false;
      try{ root.scrollIntoView({behavior:'smooth',block:'center'});}catch{}
      while(loop){
        for (const s of cur){
          if (!loop) break;
          out.innerHTML = '<strong>'+esc(s.g)+'</strong>: '+esc(s.ex.join(', '));
          await Queue.speak([{ text: s.g, pauseMs: 250 }, ...s.ex.map(w=>({ text:w, pauseMs: 220 }))], { rate: 1.0 });
          await sleep(prefersReduce? 500: 200);
        }
      }
    });
    on(btnStop,'click', ()=>{ loop=false; Queue.cancel(); btnStop.disabled=true; });
    on(btnCam,'click', async ()=>{
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        mirror.srcObject = stream; mirrorWrap.style.display='';
        btnCamOff.disabled=false;
      }catch(e){ out.textContent = 'Camera permission not granted.'; }
    });
    on(btnCamOff,'click', ()=>{
      const s = mirror.srcObject; if (s) s.getTracks().forEach(t=>t.stop());
      mirror.srcObject=null; mirrorWrap.style.display='none'; btnCamOff.disabled=true;
    });
  }

  function pronLab(){
    const root = qs('#pronLab'); if (!root) return;
    const grid = root.querySelector('.grid'), out = qs('#pronOut'), btnPractice = qs('#pronPractice'), btnStop = qs('#pronStop');
    const SETS = [
      {g:'a',ex:['apple','able']},{g:'e',ex:['egg','even']},{g:'i',ex:['ink','idea']},{g:'o',ex:['odd','open']},{g:'u',ex:['up','unit']},
      {g:'sh',ex:['ship','brush']},{g:'ch',ex:['chip','teacher']},{g:'th',ex:['thin','this']},{g:'ph',ex:['phone','graph']},{g:'wh',ex:['when','whale']},
      {g:'ai',ex:['rain','train']},{g:'ee',ex:['seen','green']},{g:'ea',ex:['team','leave']},{g:'oa',ex:['boat','coast']},{g:'ow',ex:['slow','grow']},
      {g:'oi',ex:['coin','point']},{g:'oy',ex:['boy','enjoy']},{g:'ou',ex:['out','sound']},{g:'aw',ex:['saw','dawn']},{g:'au',ex:['cause','launch']},
      {g:'ar',ex:['car','sharp']},{g:'er',ex:['her','fern']},{g:'ir',ex:['bird','shirt']},{g:'or',ex:['for','storm']},{g:'ur',ex:['turn','nurse']},
      {g:'igh',ex:['high','night']},{g:'tch',ex:['catch','match']},{g:'dge',ex:['bridge','edge']},{g:'kn',ex:['knock','knee']},{g:'wr',ex:['write','wrap']},{g:'mb',ex:['thumb','comb']}
    ];
    let current = null, loop=false;
    SETS.forEach(s=>{
      const b = document.createElement('button');
      b.type='button'; b.className='btn'; b.style.minWidth='72px'; b.textContent=s.g;
      on(b, 'click', async ()=>{
        current = s; out.innerHTML = '<strong>'+esc(s.g)+'</strong>: '+esc(s.ex.join(', '));
        await Queue.speak([{ text: s.g, pauseMs: 250 }, ...s.ex.map(w=>({ text:w, pauseMs: 220 }))], { rate: 1.0 });
        btnPractice.disabled=false; btnStop.disabled=false;
      });
      grid.appendChild(b);
    });
    on(btnPractice,'click', async ()=>{
      if (!current) return;
      loop = true; btnStop.disabled=false;
      while(loop){ for (const w of current.ex){ if(!loop) break; await Queue.speak([{ text: w, pauseMs: 150 }]); await sleep(prefersReduce? 400: 150); } }
    });
    on(btnStop,'click', ()=>{ loop=false; Queue.cancel(); btnStop.disabled=true; });
  }

  function laddersAffixes(){
    const root = qs('#vcLadder'); if (!root) return;
    const setSel = qs('#ladderPick'), playBtn = qs('#ladderPlay'), stopBtn = qs('#ladderStop');
    const baseInp = qs('#morphBase'), affInp = qs('#morphAff'), morphPlay = qs('#morphPlay'), morphStop = qs('#morphStop');
    const out = qs('#vcLadderOut');
    const SETS = {
      cat: ['cat','cot','coat','coast','toast','boast'],
      pin: ['pin','pan','pain','plain','plane'],
      hop: ['hop','hope','hose','those'],
      light: ['light','right','fright','bright']
    };
    let loop=false;
    on(playBtn,'click', async ()=>{
      const seq = SETS[setSel.value] || [];
      if (!seq.length) return;
      loop = true; stopBtn.disabled=false; try{ root.scrollIntoView({behavior:'smooth',block:'center'});}catch{}
      out.textContent = seq.join(' → ');
      for (const w of seq){ if(!loop) break; await Queue.speak([{ text: w, pauseMs: 220 }]); await sleep(prefersReduce? 400: 160); }
      stopBtn.disabled=true;
    });
    on(stopBtn,'click', ()=>{ loop=false; Queue.cancel(); stopBtn.disabled=true; });

    on(morphPlay,'click', async ()=>{
      const base = (baseInp?.value || '').trim(); if (!base) return;
      let pieces = (affInp?.value || '').split(',').map(s=>s.trim()).filter(Boolean);
      const words = pieces.map(a=>{
        if (a.endsWith('-')) return a.replace(/-+$/,'') + base;
        if (a.startsWith('-')) return base + a.replace(/^-+/,'');
        return a.replace(/-+/g,'') + base;
      });
      out.textContent = words.join(' • ');
      for (const w of words){ await Queue.speak([{ text: w, pauseMs: 200 }]); await sleep(prefersReduce? 350: 120); }
    });
    on(morphStop,'click', ()=>{ Queue.cancel(); });
  }

  function breathingCoach(){
    const url = (location.pathname||'').toLowerCase();
    const map = {
      '4-7-8-breathing.html': { steps:[{t:'Inhale',s:4},{t:'Hold',s:7},{t:'Exhale',s:8}], loop:true },
      'box-breathing.html': { steps:[{t:'Inhale',s:4},{t:'Hold',s:4},{t:'Exhale',s:4},{t:'Hold',s:4}], loop:true },
      'coherent-5-5.html': { steps:[{t:'Inhale',s:5},{t:'Exhale',s:5}], loop:true },
      'sos-60.html': { steps:[{t:'Inhale',s:4},{t:'Exhale',s:6}], loop:true }
    };
    let conf = null;
    for (const key of Object.keys(map)){ if (url.endsWith('/'+key) || url.endsWith(key)) { conf = map[key]; break; } }
    const startBtn = qs('[id*="start"][type="button"], .btn.btn-success[data-start], #pStart');
    const stopBtn  = qs('[id*="stop"][type="button"], #pStop');
    if (!conf && !startBtn) return;

    let running=false, cancelled=false;
    async function run(){
      if (!conf) return;
      running = true; cancelled = false;
      while (running && !cancelled){
        for (const step of conf.steps){
          if (cancelled) break;
          await Queue.speak([{ text: step.t }], { rate: 0.98 });
          await sleep(step.s*1000);
        }
        if (!conf.loop) break;
      }
    }
    on(startBtn, 'click', ()=>{ cancelled=false; running=true; run(); });
    on(stopBtn, 'click', ()=>{ cancelled=true; running=false; Queue.cancel(); });
    on(window, 'beforeunload', ()=>{ Queue.cancel(); });
    document.addEventListener('visibilitychange', ()=>{ if (document.hidden) Queue.cancel(); });
  }

  function siteReader(){
    function sectionFor(el){
      if (!el) return null;
      let n = el;
      while (n && n !== document.body){
        if (n.id && (n.tagName==='SECTION' || n.classList.contains('card'))) return n;
        n = n.parentElement;
      }
      return document.body;
    }
    document.addEventListener('keydown', (e)=>{
      if (e.altKey && (e.key==='r' || e.key==='R')){
        e.preventDefault();
        const sel = window.getSelection?.();
        const text = sel && String(sel).trim();
        if (text){
          Queue.speak([{ text }]);
        } else {
          const el = sectionFor(document.activeElement);
          const txt = (el?.innerText || '').replace(/\\s+/g,' ').trim();
          if (txt) Queue.speak([{ text: txt }]);
        }
      } else if (e.key==='Escape'){
        Queue.cancel();
      }
    });
  }

  // ---------- Boot ----------
  window.addEventListener('click', async ()=>{ try{ await (new (window.AudioContext||window.webkitAudioContext)()).resume(); }catch{} }, { once:true });
  document.addEventListener('DOMContentLoaded', ()=>{
    try{ segmentBlendUI(); }catch(e){ console.warn(e); }
    try{ soundStudio(); }catch(e){ console.warn(e); }
    try{ pronLab(); }catch(e){ console.warn(e); }
    try{ laddersAffixes(); }catch(e){ console.warn(e); }
    try{ breathingCoach(); }catch(e){ console.warn(e); }
    try{ siteReader(); }catch(e){ console.warn(e); }
  });
})();`;

  // --- Draggable panel enhancement (your code, professionally corrected) ---
  const jsDrag = `
// ==========================================================================
/* Voice Coach Panel Draggable — movable with "Move" handle
   Targets any of: #voiceCoach, .voice-coach, [data-voice-coach], .coach-panel
   Persists position in localStorage ("mpl.voicecoach.pos").
   Adds CSS class .voice-coach-draggable and child .vc-drag-handle. */
// ==========================================================================
(() => {
  const SELECTORS = ['#voiceCoach', '.voice-coach', '[data-voice-coach]', '.coach-panel'];

  function clamp(v, min, max) { v = Number(v); if (Number.isNaN(v)) v = min; return Math.max(min, Math.min(v, max)); }

  function makeDraggable(panel) {
    if (!panel || panel.__vcDraggable) return;
    panel.__vcDraggable = true;

    // Ensure fixed positioning & stacking
    const style = panel.style;
    const cs = getComputedStyle(panel);
    if (cs.position !== 'fixed') style.position = 'fixed';
    if (!style.zIndex) style.zIndex = '2147483000'; // keep above app chrome

    const rect = panel.getBoundingClientRect();
    panel.classList.add('voice-coach-draggable');
    if (!style.left) style.left = clamp(rect.left, 8, (window.innerWidth - rect.width - 8)) + 'px';
    if (!style.top) style.top = clamp(rect.top, 8, (window.innerHeight - rect.height - 8)) + 'px';

    // Create a small drag handle (top-left by default)
    let handle = panel.querySelector(':scope > .vc-drag-handle');
    if (!handle) {
      handle = document.createElement('div');
      handle.className = 'vc-drag-handle';
      handle.textContent = 'Move';
      panel.appendChild(handle);
    }

    let drag = { active: false, sx: 0, sy: 0, sl: 0, st: 0 };
    const key = 'mpl.voicecoach.pos';

    const start = (e) => {
      drag.active = true;
      const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
      drag.sx = p.clientX; drag.sy = p.clientY;
      drag.sl = parseFloat(style.left) || rect.left;
      drag.st = parseFloat(style.top) || rect.top;
      document.addEventListener('mousemove', move, { passive: false });
      document.addEventListener('mouseup', end);
      document.addEventListener('touchmove', move, { passive: false });
      document.addEventListener('touchend', end);
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
    };

    const move = (e) => {
      if (!drag.active) return;
      const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
      const nx = drag.sl + (p.clientX - drag.sx);
      const ny = drag.st + (p.clientY - drag.sy);
      const maxX = window.innerWidth - panel.offsetWidth - 8;
      const maxY = window.innerHeight - panel.offsetHeight - 8;
      style.left = clamp(nx, 8, Math.max(8, maxX)) + 'px';
      style.top  = clamp(ny, 8, Math.max(8, maxY)) + 'px';
      if (e.cancelable) e.preventDefault();
    };

    const end = () => {
      if (!drag.active) return;
      drag.active = false;
      document.removeEventListener('mousemove', move);
      document.removeEventListener('mouseup', end);
      document.removeEventListener('touchmove', move);
      document.removeEventListener('touchend', end);
      try { localStorage.setItem(key, JSON.stringify({ left: style.left, top: style.top })); } catch {}
    };

    handle.addEventListener('mousedown', start);
    handle.addEventListener('touchstart', start, { passive: false });

    // Load saved position
    try {
      const saved = JSON.parse(localStorage.getItem(key) || 'null');
      if (saved && typeof saved.left === 'string' && typeof saved.top === 'string') {
        style.left = saved.left;
        style.top = saved.top;
      }
    } catch {}

    // Keep within viewport on resize/rotate
    window.addEventListener('resize', () => {
      const maxX = window.innerWidth - panel.offsetWidth - 8;
      const maxY = window.innerHeight - panel.offsetHeight - 8;
      const l = parseFloat(style.left) || 8;
      const t = parseFloat(style.top) || 8;
      style.left = clamp(l, 8, Math.max(8, maxX)) + 'px';
      style.top  = clamp(t, 8, Math.max(8, maxY)) + 'px';
    }, { passive: true });
  }

  function findPanel() {
    for (const sel of SELECTORS) {
      const el = document.querySelector(sel);
      if (el) return el;
    }
    return null;
  }

  const init = () => {
    const panel = findPanel();
    if (panel) { makeDraggable(panel); return; }
    // If Voice Coach mounts later, watch for it
    const obs = new MutationObserver(() => {
      const p = findPanel();
      if (p) { makeDraggable(p); obs.disconnect(); }
    });
    obs.observe(document.body, { childList: true, subtree: true });
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();`;

  const output = jsCore + '\n' + jsDrag;
  fs.writeFileSync(OUT_FILE, output, 'utf8');
}

// Inject minimal CSS once (per HTML) for the draggable handle & panel
function injectDraggableCSS(html) {
  if (/VoiceCoach draggable styles/i.test(html)) return html; // already injected

  const styleBlock = `
  <!-- VoiceCoach draggable styles -->
  <style>
    .voice-coach-draggable{ position:fixed !important; z-index:2147483000 !important; touch-action:none; }
    .voice-coach-draggable .vc-drag-handle{
      position:absolute; top:6px; left:6px; font:600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding:4px 8px; border-radius:999px; border:1px solid rgba(0,0,0,.15);
      background:rgba(255,255,255,.85); backdrop-filter:saturate(1.2) blur(4px);
      box-shadow:0 1px 3px rgba(0,0,0,.2); cursor:move; user-select:none;
    }
    .voice-coach-draggable .vc-drag-handle:active{ transform:scale(.98); }
  </style>`;

  // place before </head> if possible; else at top of <body>
  if (/<\/head>/i.test(html)) {
    return html.replace(/<\/head>/i, `${styleBlock}\n</head>`);
  }
  if (/<body[^>]*>/i.test(html)) {
    return html.replace(/<body[^>]*>/i, (m) => `${m}\n${styleBlock}\n`);
  }
  return `${styleBlock}\n${html}`;
}

function patchHtmlFile(filePath) {
  let html = fs.readFileSync(filePath, 'utf8');
  let orig = html;

  // 1) Remove old Voice Coach includes
  html = html
    .replace(/<link[^>]+href=["']_coach\/voice-coach\.css["'][^>]*>\s*/gi, '')
    .replace(/<script[^>]+src=["']_coach\/voice-coach\.js["'][^>]*>\s*<\/script>\s*/gi, '')
    .replace(/<script[^>]+src=["']coach\.js["'][^>]*>\s*<\/script>\s*/gi, '');

  // 2) Inject the new runtime before </body> (idempotent)
  const injectTag = `<script defer src="assets/js/voice-coach-pro.js"></script>`;
  if (!/voice-coach-pro\.js/i.test(html)) {
    html = html.replace(/<\/body>\s*<\/html>\s*$/i, `${injectTag}\n</body>\n</html>`);
    if (!/voice-coach-pro\.js/i.test(html)) {
      // If no </body> match (rare), append at end
      html += `\n${injectTag}\n`;
    }
  }

  // 3) Ensure draggable CSS exists
  html = injectDraggableCSS(html);

  // 4) Add the requested Start button to the Segment & Blend tile (only if area exists and button not yet present)
  if (html.includes('id="vcPhon"') && html.includes('id="vcPlay"') && !html.includes('id="vcStart"')) {
    html = html.replace(
      /(<div class="actions">\s*)(<button[^>]*id="vcPlay"[^>]*>Model segment→blend<\/button>)/i,
      `$1<button id="vcStart" class="btn btn-success" type="button">Start</button>\n                $2`
    );
  }

  if (html !== orig) {
    fs.writeFileSync(filePath, html, 'utf8');
    return true;
  }
  return false;
}

// ---------- Main ----------
(function main() {
  writeVoiceCoachFile();

  const all = walk(ROOT).filter(p => p.toLowerCase().endsWith('.html'));
  let changed = 0;
  for (const f of all) {
    const ok = patchHtmlFile(f);
    if (ok) changed++;
  }

  console.log('✔ Voice Coach Pro installed at:', path.relative(ROOT, OUT_FILE));
  console.log('✔ HTML pages scanned:', all.length);
  console.log('✔ Pages updated:', changed);
  if (PROVIDER === 'azure') {
    console.log('Provider: Azure Speech — voice:', AZURE_VOICE, 'region:', AZURE_REGION);
  } else if (PROVIDER === 'elevenlabs') {
    console.log('Provider: ElevenLabs — voiceId:', EL_VOICE_ID);
  } else {
    console.log('Provider: Web Speech (system voice) — set VOICECOACH_PROVIDER=azure or elevenlabs to upgrade.');
  }
})();
